아래는 **제3장: WebGL 렌더링 파이프라인 이해 및 기본 구조 구현** 교재 예시입니다. 이 장에서는 WebGL의 렌더링 파이프라인이 어떻게 동작하는지 개념적으로 이해하고, 기본적인 WebGL 애플리케이션의 구조를 직접 구현해봄으로써 전체 프로세스를 체험해 본다.

---

# 제3장: WebGL 렌더링 파이프라인 이해 및 기본 구조 구현

## 3.1 서론

현대 3D 그래픽스 시스템은 복잡한 계산 과정을 거쳐 3D 데이터를 화면에 렌더링한다. WebGL은 이러한 렌더링 파이프라인을 웹 브라우저 환경에 맞게 구현한 API로, GPU를 활용하여 실시간 렌더링을 가능하게 한다. 본 장에서는 WebGL의 렌더링 파이프라인의 각 단계를 살펴보고, 이를 기반으로 한 기본 구조를 구현하는 방법을 학습한다.

---

## 3.2 WebGL 렌더링 파이프라인 개요

WebGL 렌더링 파이프라인은 3D 데이터를 2D 화면에 출력하기 위한 일련의 처리 단계로 구성된다. 주요 단계는 다음과 같다.

### 3.2.1 파이프라인 단계

1. **정점 처리 (Vertex Processing)**
   - **입력:** 애플리케이션으로부터 전달받은 정점 데이터(위치, 색상, 텍스처 좌표 등)
   - **정점 셰이더(Vertex Shader):** 각 정점의 위치를 변환(모델 변환, 뷰 변환, 프로젝션 변환)하고, 필요한 속성을 계산한다.
  
2. **기하조립 및 래스터화 (Primitive Assembly & Rasterization)**
   - **기하조립:** 정점들이 삼각형, 선분 등 기하 도형으로 조합됨.
   - **래스터화:** 조립된 도형을 화면의 픽셀로 변환하여 프래그먼트(조각)를 생성한다.
  
3. **프래그먼트 처리 (Fragment Processing)**
   - **프래그먼트 셰이더(Fragment Shader):** 각 프래그먼트(잠재적 픽셀)의 색상 및 깊이 값을 계산한다.
   - **출력:** 최종적으로 색상이 결정된 픽셀이 프레임 버퍼에 저장되어 화면에 출력된다.
  
4. **후처리 (Post-Processing, 선택 사항)**
   - 여러 효과(안티앨리어싱, 블러, 색보정 등)를 적용하여 최종 이미지를 개선할 수 있다.

> **참고:** WebGL은 OpenGL ES 2.0 기반으로 설계되었으며, 위 단계는 기본적인 파이프라인 흐름을 단순화한 개념이다.

---

## 3.3 기본 WebGL 프로그램의 구조

WebGL 애플리케이션은 다음과 같은 기본 구조를 가진다.

1. **HTML 및 캔버스 요소 생성**
   - HTML 문서 내에 `<canvas>` 요소를 배치하여 렌더링 결과를 출력할 영역을 마련한다.
2. **WebGL 컨텍스트 획득**
   - JavaScript를 사용하여 `<canvas>`로부터 WebGL 렌더링 컨텍스트를 얻는다.
3. **셰이더 소스 정의 및 컴파일**
   - 정점 셰이더와 프래그먼트 셰이더의 GLSL 코드를 작성하고, 이를 컴파일하여 GPU에 업로드한다.
4. **셰이더 프로그램 생성 및 링크**
   - 컴파일된 셰이더들을 하나의 프로그램으로 결합하여, 렌더링 파이프라인에서 사용할 준비를 한다.
5. **버퍼 생성 및 데이터 업로드**
   - 정점 데이터(예: 위치 정보)를 버퍼에 저장하고, 셰이더의 입력 변수(attribute)에 연결한다.
6. **렌더링 설정 및 그리기**
   - 뷰포트, 깊이 테스트, 클리어 컬러 등을 설정하고, 최종적으로 `drawArrays()` 또는 `drawElements()` 함수를 호출하여 화면에 그린다.

---

## 3.4 기본 구조 구현 예제

다음은 간단한 삼각형을 렌더링하는 WebGL 프로그램 예제 코드이다. 이 예제는 위에서 설명한 기본 구조를 모두 포함하고 있으며, WebGL 렌더링 파이프라인의 흐름을 직접 체험할 수 있도록 구성되어 있다.

> **예제 설명:**  
> - **정점 셰이더:** 정점의 위치를 받아 모델뷰 및 프로젝션 변환을 적용하여 최종 클립 좌표를 계산한다.  
> - **프래그먼트 셰이더:** 모든 프래그먼트에 대해 고정된 빨간색을 출력한다.  
> - **버퍼:** 삼각형을 구성하는 3개의 정점 데이터를 업로드한다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>WebGL 기본 구조 예제</title>
  <style>
    canvas { border: 1px solid black; }
  </style>
  <!-- glMatrix 라이브러리: 행렬 및 벡터 연산을 쉽게 수행하기 위한 도구 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.3/gl-matrix-min.js"></script>
</head>
<body>
  <canvas id="glcanvas" width="640" height="480"></canvas>
  <script>
    // 1. 캔버스와 WebGL 컨텍스트 초기화
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
      alert('WebGL을 지원하지 않는 브라우저입니다.');
    }

    // 2. 셰이더 소스 코드 정의
    const vsSource = `
      attribute vec4 aVertexPosition;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      }
    `;
    const fsSource = `
      void main(void) {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);  // 모든 픽셀을 빨간색으로 출력
      }
    `;

    // 3. 셰이더 컴파일 함수
    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('셰이더 컴파일 오류: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // 4. 셰이더 프로그램 생성 및 링크 함수
    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert('셰이더 프로그램 초기화 실패: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

    // 5. 셰이더 프로그램의 속성 및 uniform 위치 가져오기
    const programInfo = {
      program: shaderProgram,
      attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
      },
      uniformLocations: {
        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
      },
    };

    // 6. 버퍼 생성 및 삼각형 정점 데이터 업로드
    function initBuffers(gl) {
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [
         0.0,  1.0,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
      return { position: positionBuffer };
    }
    const buffers = initBuffers(gl);

    // 7. 화면에 삼각형 그리기
    function drawScene(gl, programInfo, buffers) {
      // 렌더링 환경 설정
      gl.clearColor(0.0, 0.0, 0.0, 1.0);  // 검은 배경
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // 투영 행렬 생성 (원근 투영)
      const fieldOfView = 45 * Math.PI / 180;  // 45도
      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      const zNear = 0.1;
      const zFar = 100.0;
      const projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

      // 모델뷰 행렬 생성 (모델의 위치 이동)
      const modelViewMatrix = mat4.create();
      mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);

      // 정점 버퍼 바인딩 및 속성 연결
      {
        const numComponents = 3;  // (x, y, z)
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0;
        const offset = 0;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          numComponents,
          type,
          normalize,
          stride,
          offset);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
      }

      // 셰이더 프로그램 사용 및 uniform 값 전달
      gl.useProgram(programInfo.program);
      gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix);
      gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix);

      // 삼각형 그리기
      const offset = 0;
      const vertexCount = 3;
      gl.drawArrays(gl.TRIANGLES, offset, vertexCount);
    }

    // 화면에 그리기 호출
    drawScene(gl, programInfo, buffers);
  </script>
</body>
</html>
```

---

## 3.5 주요 학습 포인트

- **셰이더의 역할:**  
  - **정점 셰이더:** 입력된 정점 데이터를 변환하여 클립 좌표로 변환  
  - **프래그먼트 셰이더:** 각 프래그먼트에 대한 최종 색상 결정
- **버퍼와 데이터 전송:**  
  - 정점 데이터를 GPU에 전송하여 빠른 연산이 가능하도록 함.
- **행렬 변환:**  
  - 모델뷰 행렬과 프로젝션 행렬을 사용하여 3D 공간의 객체를 화면에 올바르게 표시.
- **렌더링 순서:**  
  - 초기화 → 셰이더 컴파일 → 버퍼 데이터 업로드 → uniform 설정 → draw 호출

---

## 3.6 연습 문제

1. **문제 1:** WebGL 렌더링 파이프라인의 각 단계(정점 처리, 래스터화, 프래그먼트 처리)의 역할을 간략히 설명하라.
2. **문제 2:** 위 예제에서 정점 셰이더와 프래그먼트 셰이더의 역할 및 코드에서 사용된 주요 uniform 변수들의 의미를 기술하라.
3. **문제 3:** 간단한 삼각형 대신 사각형(두 개의 삼각형으로 구성된)을 그리도록 버퍼 데이터를 수정해보라.

---

## 3.7 요약

- **렌더링 파이프라인 이해:** WebGL은 정점 처리, 기하조립 및 래스터화, 프래그먼트 처리 단계를 거쳐 3D 데이터를 화면에 렌더링한다.
- **기본 구조 구현:** 캔버스 생성, WebGL 컨텍스트 획득, 셰이더 컴파일 및 프로그램 생성, 버퍼와 uniform 설정, 최종 draw 호출의 과정을 통해 기본 구조를 구성한다.
- **실습의 중요성:** 직접 코드를 작성하고 실행해 봄으로써 렌더링 파이프라인의 동작 원리를 체감하고, 문제 발생 시 디버깅 방법을 익힐 수 있다.

---

## 3.8 참고 자료

- [WebGL 공식 문서](https://www.khronos.org/webgl/)
- [MDN Web Docs - WebGL](https://developer.mozilla.org/ko/docs/Web/API/WebGL_API)
- [glMatrix 라이브러리 문서](http://glmatrix.net/)

---

이로써 **제3장: WebGL 렌더링 파이프라인 이해 및 기본 구조 구현** 교재가 마무리됩니다.  
다음 강의에서는 이 기본 구조를 바탕으로 보다 복잡한 3D 장면을 구성하고, 다양한 렌더링 기법을 적용하는 방법을 학습할 예정입니다.
